"""external_integration

Revision ID: 431deb21615f
Revises: 69e2357e1a54
Create Date: 2025-12-16 18:48:00.000000

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '431deb21615f'
down_revision: Union[str, Sequence[str], None] = '69e2357e1a54'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # 1. Create External IDs Table (Partitioned)
    op.execute("""
    CREATE TABLE external_ids (
        resource_id INT NOT NULL,
        realm_id INT NOT NULL,
        resource_type_id INT NOT NULL,
        external_id TEXT NOT NULL,
        PRIMARY KEY (realm_id, resource_type_id, external_id),
        FOREIGN KEY (resource_id, realm_id, resource_type_id) REFERENCES resource (id, realm_id, resource_type_id) ON DELETE CASCADE,
        FOREIGN KEY (resource_type_id) REFERENCES resource_type(id)
    ) PARTITION BY LIST (realm_id);
    """)

    # NOTE: Automatic partition triggers removed - they cannot work in PostgreSQL
    # due to DDL restrictions in BEFORE INSERT triggers. Partitions must be 
    # created manually before inserting data.

    # 2. Upgrade Authorization Runner to support array of Roles (Active Roles)
    # Changed signature: p_role_id -> p_role_ids INT[]
    # Logic: role_id = ANY(p_role_ids) OR p_role_ids IS NULL/Empty check?
    op.execute("""
    CREATE OR REPLACE FUNCTION get_authorized_resources(
        p_realm_id INT,
        p_principal_id INT,
        p_role_ids INT[],
        p_resource_type_id INT,
        p_action_id INT,
        p_ctx JSONB
    )
    RETURNS TABLE(id INT) AS $$
    DECLARE
        v_acl_sql TEXT;
        v_final_sql TEXT;
        v_sql_cond TEXT;
        rec RECORD;
        v_authorized_ids INT[] := ARRAY[]::INT[];
        v_ctx_json TEXT;
    BEGIN
        v_ctx_json := p_ctx::TEXT;

        -- 1. Scan ACLs matching Principal OR (Active Roles)
        -- We loop through ACLs that match these criteria
        FOR rec IN
            SELECT compiled_sql, principal_id, role_id
            FROM acl
            WHERE realm_id = p_realm_id
              AND resource_type_id = p_resource_type_id
              AND action_id = p_action_id
              AND (
                  (principal_id = p_principal_id) -- User-specific rule
                  OR
                  (role_id = ANY(p_role_ids))     -- Role-based rule (matches any active role)
              )
        LOOP
            v_sql_cond := rec.compiled_sql;
            
            -- If Condition is TRUE (always allowed), we might want to return ALL resources?
            -- But usually it is "All resources of this type".
            
            -- 2. Build the Dynamic Query for this ACL Rule
            v_acl_sql := format(
                'SELECT id FROM resource WHERE realm_id = %L AND resource_type_id = %L AND %s',
                p_realm_id,
                p_resource_type_id,
                v_sql_cond
            );
            
            -- 3. Execute and collect IDs
            -- We inject the context variable 'p_ctx' using USING parameters if we used PREPARE, 
            -- but here we are using EXECUTE with placeholders in the compiled string?
            -- The compiled string uses 'p_ctx' variable reference.
            -- In PL/pgSQL EXECUTE, we can pass variables via USING.
            -- Using $1, $2, etc? The compiled SQL generated by 'trg_compile_acl_conditions_func'
            -- uses $principal.attr placeholders but compiles them to "p_ctx->'principal'..." text.
            -- So 'p_ctx' must be visible in the execution context?
            -- No, dynamic SQL doesn't inherit variables unless passed or substituted.
            -- The compiled SQL generated by `compile_condition_to_sql` uses 'p_ctx' hardcoded string as the variable name.
            -- This relies on the EXECUTE statement having access to it? 
            -- Actually, 'EXECUTE v_sql USING p_ctx' is the way.
            -- But the string has textual "p_ctx". 
            -- Wait, "p_ctx->..." is valid if p_ctx is a bound parameter $1.
            -- Compiler should generate "$1->'principal'..." instead of "p_ctx->...".
            -- Checking compiler... it uses the `ctx_var` argument. In trigger it is passed as 'p_ctx'.
            -- If compiler generates literal "p_ctx->'key'", then the SQL must define p_ctx?
            -- No, that won't work in dynamic EXECUTE unless we string-replace or use a DO block.
            -- 
            -- CORRECTION: The Compiler logic (which I reviewed) uses `ctx_var` to format the string.
            -- e.g. `format('%s->''principal''->>%L', ctx_var, attr)`.
            -- If ctx_var is passed as '$1', then the output is `$1->'principal'->>...`.
            -- This IS suitable for `EXECUTE ... USING p_ctx`.
            -- NOTE: The trigger passes 'p_ctx' string as the variable name. This implies previous design expected
            -- the variable to be named p_ctx in the scope? No, that only works for eval.
            --
            -- Let's check `compile_condition_to_sql` usage in `trg_compile_acl_conditions_func`.
            -- It passes 'p_ctx'. So compiled SQL is `p_ctx->...`.
            -- This works if we do `EXECUTE ... USING ...` ONLY if we replace `p_ctx` with `$1`.
            -- OR if we rely on a massive quirk.
            --
            -- Actually, looking at previous implementation of `get_authorized_resources` in 0a8b47 (which I wrote/reviewed),
            -- it did: `EXECUTE v_acl_sql USING p_ctx`.
            -- If `v_acl_sql` contains literal "p_ctx" text, this FAILs because `$1` is not used.
            -- Postgres EXECUTE USING requires the query string to reference parameters as $1, $2.
            --
            -- ERROR DISCOVERY: The existing system currently compiles with "p_ctx" literal.
            -- Execute using `p_ctx` works ONLY if the variable name matches? No, that's not how SQL works.
            --
            -- FIX: We must update the Trigger to pass '$1' as the ctx_var.
            -- Or `get_authorized_resources` must replace 'p_ctx' with '$1' before execution.
            -- Replacing is safer for legacy data compatibility.
            
            v_final_sql := replace(v_acl_sql, 'p_ctx', '$1');
            
            RETURN QUERY EXECUTE v_final_sql USING p_ctx;
            
        END LOOP;
        RETURN;
    END;
    $$ LANGUAGE plpgsql;
    """)
    # NOTE: The above logic has a flaw: it returns duplicates if multiple ACLs match.
    # And it executes multiple queries.
    # Ideally should use UNION. But RETURN QUERY handles valid set return?
    # It returns rows. Caller can DISTINCT.
    
    # Wait, the signature of the OLD function was (realm, principal, role, type, action, ctx).
    # The NEW one has (realm, principal, role_IDS, type, action, ctx).
    # We must DROP the old one because signature change might be ambiguous or overload.
    # Better to DROP first to ensure clean replacement.
    
    op.execute("DROP FUNCTION IF EXISTS get_authorized_resources(INT, INT, INT, INT, INT, JSONB)")
    
    # Re-apply creation (updated with array support)
    op.execute("""
    CREATE OR REPLACE FUNCTION get_authorized_resources(
        p_realm_id INT,
        p_principal_id INT,
        p_role_ids INT[], 
        p_resource_type_id INT,
        p_action_id INT,
        p_ctx JSONB
    )
    RETURNS TABLE(id INT) AS $$
    DECLARE
        v_acl_sql TEXT;
        v_final_sql TEXT;
        rec RECORD;
    BEGIN
        -- Loop through matching ACLs
        FOR rec IN
            SELECT compiled_sql
            FROM acl
            WHERE realm_id = p_realm_id
              AND resource_type_id = p_resource_type_id
              AND action_id = p_action_id
              AND (
                  (principal_id = p_principal_id)
                  OR
                  (role_id = ANY(p_role_ids))
              )
        LOOP
            -- Replace placeholder with bind param
            v_final_sql := replace(rec.compiled_sql, 'p_ctx', '$1');
            
            -- Construct Query
            -- Note: We must restrict to realm/type again in the dynamic part to ensure we use partitions?
            -- Yes, the compiled fragment is just WHERE clause logic.
            v_acl_sql := format(
                'SELECT id FROM resource WHERE realm_id = %L AND resource_type_id = %L AND %s',
                p_realm_id,
                p_resource_type_id,
                v_final_sql
            );
            
            RETURN QUERY EXECUTE v_acl_sql USING p_ctx;
        END LOOP;
        RETURN;
    END;
    $$ LANGUAGE plpgsql;
    """)

def downgrade() -> None:
    """Revert external_integration changes"""
    # NOTE: No trigger cleanup needed - triggers were removed from upgrade
    
    # 1. Drop External IDs Table
    op.execute("DROP TABLE IF EXISTS external_ids CASCADE;")
    
    # Revert Auth Runner (Single Role)
    op.execute("DROP FUNCTION IF EXISTS get_authorized_resources(INT, INT, INT[], INT, INT, JSONB)")
    
    op.execute("""
    CREATE OR REPLACE FUNCTION get_authorized_resources(
        p_realm_id INT,
        p_principal_id INT,
        p_role_id INT,
        p_resource_type_id INT,
        p_action_id INT,
        p_ctx JSONB
    )
    RETURNS TABLE(id INT) AS $$
    DECLARE
        v_sql TEXT;
        rec RECORD;
    BEGIN
        FOR rec IN
            SELECT compiled_sql FROM acl
            WHERE realm_id = p_realm_id
              AND resource_type_id = p_resource_type_id
              AND action_id = p_action_id
              AND (principal_id = p_principal_id OR role_id = p_role_id)
        LOOP
            v_sql := format('SELECT id FROM resource WHERE realm_id = %L AND resource_type_id = %L AND %s',
                p_realm_id, p_resource_type_id, replace(rec.compiled_sql, 'p_ctx', '$1'));
            RETURN QUERY EXECUTE v_sql USING p_ctx;
        END LOOP;
    END;
    $$ LANGUAGE plpgsql;
    """)
